% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/osint_colours.R
\name{take_max}
\alias{take_max}
\title{Filter an inherited ggplot dataset to return the maximum of the specified
column (optionally group_by before filtering).}
\usage{
take_max(col_to_max, group_by)
}
\arguments{
\item{col_to_max}{(name_of_column to take max - unquoted) Column you want the
maximum value of (e.g. days_since). Don't use quotation marks around column
name.}

\item{group_by}{(name_of_column to group_by - unquoted) Column you want to
group_by (e.g. country). Don't use quotation marks around column name.}
}
\value{
A unary function to be applied to inherited dataset in a ggplot2
  layer.
}
\description{
The use case of \code{take_max()} is within a ggplot layer where you want to
highlight the final data point on a curve with \code{geom_point(data =
take_max(date, country))} or \code{geom_label_repel(data = take_max(date,
country))}. The effect is to group and then filter the dataset inherited from
the previous ggplot layer down to a single row per group, so you can first
plot a curve with \code{geom_line()} and then place a point at the end of the
curve with \code{geom_point()}. If no group_by variable is provided, a single
row tibble is returned.
}
\details{
At a technical level \code{take_max()} is a nested function. It
returns a unary function (i.e. a function with only one parameter) that
filters the inherited dataset in a ggplot2 layer. Refer to the data section
of the \code{geom_point} help documentation -- the third option is "A
function will be called with a single argument, the plot data. The return
value must be a data.frame, and will be used as the layer data." At a
super-technical level -- under the hood this function uses tidy-evaluation
(tidyverse version of non-standard evaluation). Specifically, it uses double
curly braces \code{{{col_to_max}}}, which is an abstraction of
!!enquo(col_to_max) - further details at
\href{https://www.tidyverse.org/blog/2019/06/rlang-0-4-0/}{rlang blog post}
}
\examples{
\dontrun{

country_1 <- tibble::tibble(received_date = seq(from = 0,
                                                to = 10 * pi,
                                                length.out = 1000),
                            y_data = sin(received_date),
                            country = "Australia")

country_2 <- tibble::tibble(received_date = seq(from = 0,
                                                to = 10 * pi,
                                                length.out = 1000),
                            y_data = 0.125 * cos(received_date) - 0.25,
                            country = "United Kingdom")

chart_data <- dplyr::bind_rows(country_1, country_2)

ggplot2::ggplot(data = chart_data,
               mapping = ggplot2::aes(x = received_date,
                                      y = y_data,
                                      col = country,
                                      label = country)) +
 ggplot2::theme(legend.position = "none") +
 ggplot2::geom_line() +
 ggplot2::geom_point(data = osintr::take_max(received_date, country)) +
 ggrepel::geom_label_repel(data = osintr::take_max(received_date, country))

}

}
